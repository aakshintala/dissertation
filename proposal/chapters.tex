% !TeX root = proposal.tex
\section{Description of Chapters}
\label{sec:chapters}

The Instruction Set Architecture is typically the interface of choice when virtualizing CPUs. ISA virtualization has a long and storied history (IBM 360, Popek and Goldberg, Xen, VMware, etc.). While the reigning ISAs of the day (x86-64, ARM, etc.) all have special virtualization extensions for performance optimization (Intel VT, AMD-V), binary translation based virtualization schemes are still a necessity (a recent example being the HVX nested hypervisor~\cite{HVX} from 2014). However, when setting out to build a new binary translation based virtualization system, developers need a way to determine implementation and optimization priority, especially for a gargantuan ISA like x86-64. We will present a methodology (and the resulting data) that leverages user preference to systematically answer such questions in Chapter 1. This is completed work~\cite{x86-systor}.

Virtualizing a Graphics Processing Unit (GPU) for the purposes of graphics rendering is a well studied problem, with existing commercial solutions (VMware’s SVGA~\cite{dowty2009gpu}). Over the last decade, GPUs have been re-purposed for parallel general purpose compute (commonly known as GPGPU). Chapter 2 will present our findings from attempting to extend the SVGA model of GPU virtualization to cover GPGPU virtualization as well. We find that the tight coupling between ISA virtualization and device virtualization in SVGA leads to poor performance for GPGPU compute. We propose a new virtualization scheme, Trillium, that doesn’t rely on ISA virtualization and show that Trillium outperforms all other traditional virtualization schemes while retaining hypervisor interposition. Material presented in Chapter 2 will be drawn from a published paper~\cite{trillium}.

The slowing down of Moore’s law and the increasing importance of compute-heavy workloads such as Deep Neural Networks and Graph analytics have led to the proliferation of specialized compute units. These specialized processors are typically exposed to developers via a user-space API, which is typically implemented by a combination of proprietary and opaque software and hardware interfaces. Chapters 3, 4 and 5 will explore the performance implications of virtualizing the user-space API for specialized compute accelerators. Chapter 3 will present an overview of AvA, a framework that enables automated virtualization of accelerator APIs. Chapter 4 will focus on the performance implications of API-remoting based virtualization of a single specialized accelerator. Chapter 5 will explore performance issues that arise when an application uses multiple API-remoted virtual accelerators in a pipelined fashion. Chapters 3 and 4 will draw on material that appeared in a HotOS workshop paper~\cite{ava-hotos} and a full paper that is currently under submission. Chapter 5 is proposed work.

Virtualization schemes are traditionally taxonomized according to the core techniques employed (e.g. emulation, full- or para-virtualization, API remoting, etc.), and evaluated in a property trade-off space comprising performance, compatibility, interposition, and isolation. We argue that both the de facto taxonomy and the property trade-off space are illustrative but not informative for GPGPU virtualization: there is a large body of research that has had little influence on practice. We suggest an alternative framework called \texttt{IEMTS} that teases apart design axes that are implicitly and unnecessarily intertwined in much of the literature. By focusing on the \textbf{I}nterface interposed, the interposition \textbf{E}ndpoints, the \textbf{M}echanism of interposition, the \textbf{T}ransport used to move the interposed operations between the guest and the host, and the mechanism used to \textbf{S}ynthesize the interposed interface, \texttt{IEMTS} enables a clearer understanding of trade-offs in prior designs and provides a model for comparison of alternative designs. \texttt{IEMTS} will be presented in Chapter 6, along with analysis of traditional virtualization techniques in the context of GPGPUs.