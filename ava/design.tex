% -*- fill-column: 85; -*-
%!TEX root = ../dissertation.tex

\graphicspath{{images/}}

\section{Design}
\label{s:design}
\label{s:motivation}

For accelerator silos, the \emph{only} stable and
efficiently interposable interface is the framework API, so
we focus on techniques to recover or compensate virtualization properties lost by
API remoting: interposition and compatibility.
Interposition can be recovered by using hypervisor-managed forwarding transport,
creating an interface at which to enforce resource management policies.
\Model uses a novel technique called \emph{\noveltechnique (\novtechabbrv)} to achieve this.
\novtechabbrv presents guest VMs with an abstract virtual device with MMIO Base Address Registers (BARs), but this device is \emph{not a virtual accelerator}, but an endpoint that
routes communication through the hypervisor.

Using hypervisor-managed transport recovers interposition, but complicates compatibility and introduces engineering effort:
\novtechabbrv requires custom guest libraries, guest drivers, and API servers for each OS and API, and API-specific resource-management code in the hypervisor.
\model mitigates this by
automatically generating code to implement \novtechabbrv components (\S\ref{s:api}), which introduces the
need to specify API semantics and policies beyond the ability of existing Interface Description Languages (IDLs)~\cite{Lamb1987,MSIDL}.
%\Model uses a new DSL called \speclang, a compiler called \compiler, and device-agnostic transport components to address these challenges.

\Model targets \emph{compute offload} accelerator APIs,
such as OpenCL, CUDA, and TensorFlow, which control an accelerator explicitly
through data transfer and task creation interfaces.
\Model consists of API-agnostic para-virtual stack components to
implement transport and dispatch for API remoting,
API-specific components that interpose and execute the API functions,
and a compiler, \compiler, which generates the API-specific components from a
specification of the API.
The API specification is written in a new high-level specification language, \speclang.
Figure~\ref{fig:overview} shows the work-flow to support a new API with \model (\S\ref{sub:workflow}) and the \model stack.
The API-agnostic components may be deployed in the hypervisor or in an appliance VM to support type I and II hypervisors~\cite{Popek1974-xx}.

\subsection{\Model Components}
\label{sub:components}
% \hyu{Reference to Figure~\ref{fig:high_level_design}?}
Figure~\ref{fig:overview} provides an overview of the interaction
between the various components in a \model-generated design.

The \parname{guest library} is generated by \compiler from the \speclang
specification. It provides the same symbols as the vendor library for the
application to link against.
The guest library intercepts all API functions called by
guest applications, marshals function arguments and implicit
state, and forwards the call through the transport channel for
remote execution.

The \parname{guest driver} interacts with the \vdev exposed
to the VM and provides a transport channel endpoint in the VM.
% Each guest-driver manages a set of command queues that are used to forward API
% calls to the \worker via the router.
\Compiler generates a separate transport driver instance for each API framework.
%The instances are identical, but independent at runtime.
%\amp{Do we need to say this last part? It's pretty much what ``instance'' means.}
%\cjr{I agree. We don't.}
% A custom driver per API framework is necessary to preserve cross-framework isolation
% and guest OS interposition.
% \hyu{For the complete story, this is vAcc driver (for transport) + virtio driver (for mediation \& transport).}

The \parname{\vdev}
is an abstract device exposed to the
guest to forward API calls
between the guest and the \worker.
The \vdev exposes %MMIO BARs for control and
%registers~\cjr{do we actually use control registers? What for if so?}\hyu{Only 4 registers are being used: one stores vm\_id, one stores zero copy buffer's physical address, two are used to notify KVM that the guestdrv is installed. Two deprecated registers were used to notify KVM that an app is spawned.},
a command queue interface.
It is API-agnostic, and its purpose is to
provide an interposable interface for the hypervisor.

The \parname{router} is an API-agnostic extension to the hypervisor that
implements \model's interposition logic. The router performs security
checks and enforces scheduling policies on forwarded API calls according
to the \speclang specification.

The \parname{\worker} is an API-specific user-space process generated
by \compiler. It runs either in an appliance VM (with PCIe pass-through access to the physical device) or in the host
and executes forwarded calls on behalf of the guest application.
A given \Worker is dedicated to a single guest process, leveraging
process-level isolation when the hardware supports it to guarantee fault and device context isolation.
%The \worker is a trusted component---the router may rely on the \worker to
%provide semantic information that may be specific to a given API, e.g., the
%\worker may provide device resource accounting information to the router for
%resource management.

\begin{comment}
\cjr{I think we've made the point already, and we need the space.}
The router and the specialized transport that enables it distinguishes \model from API remoting and allows \model to support hypervisor level interposition.\amp{might be a strawman. Someone please check and rewrite.}
The router, the \worker, and vendor
device drivers are considered part of the Trusted Computing Base, while the
guest library and the guest \vdev driver are untrusted.

\cjr{Anyone: Add sentence saying exactly how these components are different from traditional API remoting?}
\end{comment}

\subsection{Developer Work-flow}
\label{sub:workflow}

\Model's API-agnostic components (\S\ref{sub:components}) must be implemented for each hypervisor, along with the guest drivers
needed for each supported guest OS. The development effort to build them
is amortized across all of the accelerators and framework APIs supported.
%% The guest driver is only implemented once, but the illusion of having a
%% separate driver per API framework (necessary for isolating API frameworks and
%% maintaining interposition in the guest OS) is maintained by automatically
%% generating driver registration code for each API framework.

\Model's API-specific components are generated from \speclang by \compiler to
plug into \model's API-agnostic components.
% \Model uses \speclang (\S\ref{s:api}), which is used to annotate the APIs and
% accelerator resources, to automate the construction of the API remoting system
% for \emph{any} accelerator API.
% \reviewer{A}{How automated is the process if the programmer must annotate the API? What happens if the API changes?}
Figure~\ref{fig:overview} shows the work-flow to support a new API with \model.
First, \compiler automatically generates a preliminary \speclang specification from the unmodified header file.
% \cjr{Do we assert that the preliminary spec is correct but unoptimized? If not, how do we ensure the user deals with every missing element/problem area?}
% \hyu{Addressed by AMP in CAvA section.}
The programmer refines the specification with guidance from \compiler; adding information missing from the header file, e.g., buffer sizes or implicitly referenced state.
% , providing only the information that \compiler cannot infer.
Once the developer is satisfied with the API specification, she invokes
\compiler to generate code for the API-specific components and the customized
driver. \Compiler also generates deployment scripts.
% for compiling the generated code, and for integrating it with the API-agnostic components.
When a new version of an API is released, the same process can be used, starting with the previous specification.
