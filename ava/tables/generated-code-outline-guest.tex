% -*- fill-column: 85; -*-
%!TEX root = main.tex

\begin{figure}
\begin{lstlisting}[language=C,columns=flexible,mathescape,belowskip=0em,aboveskip=0em,basicstyle={\scriptsize\ttfamily}]
CUresult cuStreamSynchronize(CUstream stream) {
  // Allocate and initialize the command
  cu_stream_synchronize_call *cmd = $\txt{allocate}$;
  cmd->command_id = CALL_CU_STREAM_SYNCHRONIZE;
  cmd->call_id = generate_call_id(); // Unique call ID
  cmd->stream = stream;                    // Copy simple value
  // Compute and attach contextual parameter bufs
  void **bufs = get_bufs(async_DtoH, stream);
  size_t nbufs = get_n_bufs(async_DtoH, stream);
  // Attached buffers referenced from bufs
  void **tmp_bufs = $\txt{allocate and fill with output buffer sentinal}$;$\label{line:bufs-start}$
  cmd->bufs = attach_buffer(cmd, tmp_bufs, 
     get_n_bufs(async_DtoH, stream) *$$ sizeof(void *));$\label{line:bufs-end}$
  // Create and register a local record of the call
  cu_stream_synchronize_record *record = $\txt{alloc}$();
  record->stream = stream; record->bufs = bufs;
  record->call_complete = 0; register_call(record);
  // Send the command and wait for and return response
  send_command(cmd);
  wait_until(record->call_complete);
  return record->ret; }
CUresult cuMemcpyDtoHAsync(void *dst, CUdeviceptr src, 
                               size_t size, CUstream stream) {
  |\elidedcode{Allocate and initialize the command as above}|
  // Execute state-tracking code from spec
  register_buf(async_DtoH, stream, dst, size);
  |\elidedcode{Store and attach arguments similar to above}|
  |\elidedcode{Create and register a local record of the call, and send}|
  // Return the success value from LAPIS specification
  return CUDA_SUCCESS; }
\end{lstlisting}
\caption{An outline of the generated guestlib code for \spec|cuStreamSynchronize| and \spec|cuMemcpyDtoHAsync|. 
The real code manages a number of additional details, e.g., threads.
}
\label{fig:generated-code-outline-guest}
\vspace*{-0.5em}
\end{figure}
